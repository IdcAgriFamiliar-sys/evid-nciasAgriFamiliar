import React, { useState, useEffect } from 'react';
import { initializeApp } from 'firebase/app';
import {
  getAuth,
  signInAnonymously,
  signInWithCustomToken,
  onAuthStateChanged,
} from 'firebase/auth';
import {
  getFirestore,
  collection,
  query,
  onSnapshot,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  serverTimestamp,
  setLogLevel,
} from 'firebase/firestore';

// --- Variáveis Globais (Fornecidas pelo Ambiente Canvas) ---

const firebaseConfig = typeof __firebase_config !== 'undefined'
  ? JSON.parse(__firebase_config)
  : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined'
  ? __initial_auth_token
  : null;

// --- Configuração e Inicialização do Firebase ---
// Define as variáveis globais para a aplicação
let app;
let db;
let auth;

// Esta função assíncrona garante que o Firebase seja inicializado
// e o usuário esteja autenticado antes de qualquer interação com o Firestore.
const initializeFirebase = async () => {
  try {
    if (Object.keys(firebaseConfig).length === 0) {
      console.error("Firebase Configuração não encontrada.");
      return;
    }

    // Inicializa o Firebase
    app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);

    // Opcional: Ativa logs de debug para o Firestore
    setLogLevel('debug');

    // Autentica o usuário
    if (initialAuthToken) {
      await signInWithCustomToken(auth, initialAuthToken);
      console.log('Autenticação com token personalizada bem-sucedida.');
    } else {
      await signInAnonymously(auth);
      console.log('Autenticação anônima bem-sucedida.');
    }

    // Retorna as instâncias para uso no componente
    return { db, auth };
  } catch (error) {
    console.error('Erro ao inicializar o Firebase ou autenticar:', error);
    return null;
  }
};

const TaskItem = ({ task, onToggle, onDelete, onEdit }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [newText, setNewText] = useState(task.text);

  const handleSave = () => {
    onEdit(task.id, newText);
    setIsEditing(false);
  };

  return (
    <li className="flex items-center justify-between p-3 my-2 bg-white/10 rounded-xl shadow-md transition duration-300 hover:shadow-lg">
      <div className="flex items-center flex-1 min-w-0">
        <input
          type="checkbox"
          checked={task.completed}
          onChange={() => onToggle(task.id, !task.completed)}
          className="form-checkbox h-5 w-5 text-indigo-500 rounded-lg cursor-pointer transition duration-150 ease-in-out border-gray-300 mr-4 focus:ring-indigo-500"
        />

        {isEditing ? (
          <input
            type="text"
            value={newText}
            onChange={(e) => setNewText(e.target.value)}
            onBlur={handleSave}
            onKeyDown={(e) => {
              if (e.key === 'Enter') handleSave();
            }}
            className="flex-1 px-2 py-1 bg-white/20 border-b border-indigo-300 focus:outline-none focus:border-indigo-500 text-gray-100 rounded-md transition duration-200"
            autoFocus
          />
        ) : (
          <span
            className={`flex-1 min-w-0 truncate text-lg text-gray-100 ${
              task.completed ? 'line-through text-gray-400' : ''
            }`}
            onClick={() => setIsEditing(true)}
            title="Clique para editar"
          >
            {task.text}
          </span>
        )}
      </div>

      <div className="flex space-x-2 ml-4">
        {isEditing ? (
          <button
            onClick={handleSave}
            className="text-green-400 hover:text-green-300 p-1 rounded-full transition duration-150"
            title="Salvar"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              className="h-6 w-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M5 13l4 4L19 7"
              />
            </svg>
          </button>
        ) : (
          <button
            onClick={() => setIsEditing(true)}
            className="text-yellow-400 hover:text-yellow-300 p-1 rounded-full transition duration-150"
            title="Editar"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              className="h-6 w-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"
              />
            </svg>
          </button>
        )}
        <button
          onClick={() => onDelete(task.id)}
          className="text-red-400 hover:text-red-300 p-1 rounded-full transition duration-150"
          title="Excluir"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-6 w-6"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
            />
          </svg>
        </button>
      </div>
    </li>
  );
};

export default function App() {
  const [dbInstance, setDbInstance] = useState(null);
  const [authInstance, setAuthInstance] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [tasks, setTasks] = useState([]);
  const [newTask, setNewTask] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Efeito 1: Inicialização do Firebase e Autenticação
  useEffect(() => {
    initializeFirebase().then((instances) => {
      if (instances) {
        setDbInstance(instances.db);
        setAuthInstance(instances.auth);
        
        // Listener de estado de autenticação para definir o userId
        const unsubscribe = onAuthStateChanged(instances.auth, (user) => {
          if (user) {
            setUserId(user.uid);
          } else {
            // Caso raro onde a autenticação falhe ou o usuário saia.
            setUserId(crypto.randomUUID()); // Usa um ID temporário
          }
          setIsAuthReady(true);
          setLoading(false);
        });

        return () => unsubscribe();
      } else {
        setError('Falha na inicialização do Firebase.');
        setLoading(false);
      }
    });
  }, []);

  // Efeito 2: Escuta em tempo real dos documentos (onSnapshot)
  useEffect(() => {
    if (!isAuthReady || !dbInstance || !userId) {
      // Impede a execução de consultas antes da autenticação
      return;
    }

    // Estrutura de coleção privada: /artifacts/{appId}/users/{userId}/tasks
    const tasksCollectionRef = collection(
      dbInstance,
      'artifacts',
      appId,
      'users',
      userId,
      'tasks'
    );

    // Consulta básica (sem orderBy para evitar erros de índice)
    const q = query(tasksCollectionRef);

    // Inicia o listener de tempo real
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const tasksData = [];
      snapshot.forEach((doc) => {
        const data = doc.data();
        // Garante que o ID do documento seja incluído no objeto da tarefa
        tasksData.push({ id: doc.id, ...data });
      });

      // Ordena em memória por timestamp de criação (se disponível) ou por texto
      tasksData.sort((a, b) => {
        if (a.createdAt && b.createdAt) {
          return a.createdAt.toDate() - b.createdAt.toDate();
        }
        return a.text.localeCompare(b.text);
      });
      
      setTasks(tasksData);
      setLoading(false);
    }, (err) => {
      console.error('Erro no onSnapshot (Firestore):', err);
      setError('Não foi possível carregar as tarefas em tempo real.');
      setLoading(false);
    });

    // Limpeza: desliga o listener quando o componente é desmontado
    return () => unsubscribe();
  }, [isAuthReady, dbInstance, userId]); // Dependências cruciais

  const handleAddTask = async (e) => {
    e.preventDefault();
    if (!newTask.trim() || !dbInstance || !userId) return;

    try {
      // Define a referência da coleção
      const tasksCollectionRef = collection(
        dbInstance,
        'artifacts',
        appId,
        'users',
        userId,
        'tasks'
      );
      
      // Adiciona o documento
      await addDoc(tasksCollectionRef, {
        text: newTask.trim(),
        completed: false,
        createdAt: serverTimestamp(), // Usa o timestamp do servidor
      });
      setNewTask(''); // Limpa o campo de entrada
    } catch (err) {
      console.error('Erro ao adicionar tarefa:', err);
      setError('Falha ao salvar a nova tarefa. Tente novamente.');
    }
  };

  const handleToggleTask = async (id, completed) => {
    if (!dbInstance || !userId) return;
    try {
      // Define a referência do documento
      const taskDocRef = doc(
        dbInstance,
        'artifacts',
        appId,
        'users',
        userId,
        'tasks',
        id
      );
      // Atualiza o campo 'completed'
      await updateDoc(taskDocRef, { completed });
    } catch (err) {
      console.error('Erro ao alternar o status da tarefa:', err);
      setError('Falha ao atualizar o status da tarefa.');
    }
  };

  const handleEditTask = async (id, newText) => {
    if (!newText.trim() || !dbInstance || !userId) return;
    try {
      const taskDocRef = doc(
        dbInstance,
        'artifacts',
        appId,
        'users',
        userId,
        'tasks',
        id
      );
      await updateDoc(taskDocRef, { text: newText.trim() });
    } catch (err) {
      console.error('Erro ao editar tarefa:', err);
      setError('Falha ao editar a tarefa.');
    }
  };

  const handleDeleteTask = async (id) => {
    if (!dbInstance || !userId) return;
    try {
      const taskDocRef = doc(
        dbInstance,
        'artifacts',
        appId,
        'users',
        userId,
        'tasks',
        id
      );
      // Exclui o documento
      await deleteDoc(taskDocRef);
    } catch (err) {
      console.error('Erro ao excluir tarefa:', err);
      setError('Falha ao excluir a tarefa.');
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-900">
        <div className="text-xl text-indigo-400">Carregando a aplicação...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen p-4 sm:p-8 bg-gray-900 flex flex-col items-center font-inter">
      <div className="w-full max-w-2xl bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-2xl">
        <header className="mb-8 border-b border-indigo-500 pb-4">
          <h1 className="text-4xl font-extrabold text-white text-center tracking-tight">
            Lista de Tarefas (Firestore)
          </h1>
          <p className="text-sm text-gray-400 mt-2 text-center">
            Suas tarefas são salvas em tempo real no Firestore ({appId})
          </p>
          <div className="mt-4 text-xs text-center p-2 bg-indigo-900/50 rounded-lg">
            <span className="font-semibold text-indigo-300">ID do Usuário: </span>
            <span className="break-all text-gray-300">{userId || 'Desconhecido'}</span>
          </div>
        </header>

        {error && (
          <div className="p-4 mb-4 text-sm text-red-100 bg-red-600 rounded-lg" role="alert">
            {error}
          </div>
        )}

        {/* Formulário para Adicionar Tarefa */}
        <form onSubmit={handleAddTask} className="flex mb-8 space-x-3">
          <input
            type="text"
            value={newTask}
            onChange={(e) => setNewTask(e.target.value)}
            placeholder="O que precisa ser feito hoje?"
            className="flex-1 p-3 border border-indigo-600 rounded-xl bg-gray-700 text-white focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 shadow-inner placeholder-gray-400 transition duration-300"
          />
          <button
            type="submit"
            className="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-xl hover:bg-indigo-500 transition duration-300 transform hover:scale-105 shadow-lg active:scale-100"
          >
            Adicionar
          </button>
        </form>

        {/* Lista de Tarefas */}
        <ul className="space-y-3">
          {tasks.length > 0 ? (
            tasks.map((task) => (
              <TaskItem
                key={task.id}
                task={task}
                onToggle={handleToggleTask}
                onDelete={handleDeleteTask}
                onEdit={handleEditTask}
              />
            ))
          ) : (
            <li className="text-center text-gray-400 p-8 bg-gray-700/50 rounded-xl">
              Nenhuma tarefa encontrada. Adicione uma nova acima!
            </li>
          )}
        </ul>
      </div>
    </div>
  );
}
